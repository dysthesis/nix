#+title: Bar modules
#+auto_tangle:y

* Panel buttons
:PROPERTIES:
:header-args:js: :tangle PanelButton.js
:END:

** Imports
#+begin_src js
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import App from 'resource:///com/github/Aylur/ags/app.js';
#+end_src

** Export
#+begin_src js
/**
 * @typedef {Object} PanelButtonProps
 * @property {any} content
 * @property {string=} window
 */

/**
 * @param {import('types/widgets/button').ButtonProps & PanelButtonProps} o
 */
export default ({
    class_name,
    content,
    window = '',
    connections = [],
    ...rest
}) => {
    let open = false;

    const connection = [App, (self, win, visible) => {
        if (win !== window)
            return;

        if (open && !visible) {
            open = false;
            self.toggleClassName('active', false);
        }

        if (visible) {
            open = true;
            self.toggleClassName('active');
        }
    }];

    return Widget.Button({
        class_name: `panel-button ${class_name}`,
        child: Widget.Box({ children: [content] }),
        connections: connections.concat([connection]),
        ...rest,
    });
};
#+end_src

* Workspaces
:PROPERTIES:
:header-args:js: :tangle Workspaces.js
:END:

** Imports
*** AGS services modules
#+begin_src js
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import Hyprland from 'resource:///com/github/Aylur/ags/service/hyprland.js';
import * as Utils from 'resource:///com/github/Aylur/ags/utils.js';
#+end_src

*** Options
#+begin_src js
import options from '../../../config/options.js';
#+end_src

*** Utilities
#+begin_src js
import { range } from '../../../utils/misc/main.js';
#+end_src

** Dispatch
A helper function to dispatch to a specific workspace. Takes in a workspace number, and executes =hyprctl dispatch workspace= for that workspace number.

#+begin_src js
const dispatch = arg => Utils.execAsync(`hyprctl dispatch workspace ${arg}`);
#+end_src

** Widget
A function that returns the actual workspace widget itself. It is done this way to allow for widget reusability.

#+begin_src js :noweb yes
const Workspaces = () => {
  const ws = options.workspaces;
  return Widget.Box({
      <<workspaces-buttons>>
      <<workspaces-connections>>
  });
};
#+end_src

*** Buttons
The buttons for each workspace can be created by mapping an array of integers representing these workspaces to an array of buttons.

#+name:workspaces-buttons
#+begin_src js :tangle no :noweb yes
children: range(ws || 20).map(i => Widget.Button({
  setup: btn => btn.id = 1,
  on_clicked: () => dispatch(i),
  child: Widget.Label({
    label: `${i}`,
    class_name: 'indicator',
    vpack: 'center',
  }),
  connections: [[Hyprland, btn => {
    btn.toggleClassName('active', Hyprland.active.workspace.id === i);
    btn.toggleClassName('occupied', Hyprland.getWorkspace(i)?.windows > 0);
  }]],
})),
#+end_src

- =vpack= is the vertical packing, defining the vertical alignment of these buttons.
- Each button has a child in the form of a =Widget.Label= which displays the workspace number they represent.
- The buttons can have different classes depending on certain conditions
  - If the workspace is currently in focus, it gets the class =active=.
  - If the workspace has at least one window in it, it gets the class =occupied=.

*** Connnections
Only make the buttons visible if the workspaces which they correspond to actually exist.

#+name:workspaces-connections
#+begin_src js :noweb yes :tangle no
connections: ws ? [] : [[Hyprland.active.workspace, box => box.children.map(btn => {
            btn.visible = Hyprland.workspaces.some(ws => ws.id === btn.id);
})]],
#+end_src

** Export
#+begin_src js
export default () => Widget.Box({
  class_name: 'workspaces panel-button',
  child: Widget.Box({
    // its nested like this to keep it consistent with other PanelButton widgets
    child: Widget.EventBox({
      on_scroll_up: () => dispatch('m+1'),
      on_scroll_down: () => dispatch('m-1'),
      class_name: 'eventbox',
      binds: [['child', options.workspaces, 'value', Workspaces]],
    }),
  }),
});
#+end_src

* System tray
:PROPERTIES:
:header-args:js: :tangle SysTray.js
:END:

** Imports
*** AGS service modules
#+begin_src js
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import SystemTray from 'resource:///com/github/Aylur/ags/service/systemtray.js';
#+end_src

*** Panel buttons
#+begin_src js
import PanelButton from './PanelButton.js';
#+end_src

*** Graphical Drawing Kit
#+begin_src js
import Gdk from 'gi://Gdk';
#+end_src

** Widget
#+begin_src js :noweb yes
const SysTrayItem = item => PanelButton({
  class_name: 'tray-item',
  content: Widget.Icon({ binds: [['icon', item, 'icon']] }),
  binds: [['tooltipMarkup', item, 'tooltip-markup']],
    <<systray-setup>>
    <<systray-click-actions>>
});
#+end_src

*** Setup
#+name:systray-setup
#+begin_src js :tangle no :noweb yes
setup: self => {
  const id = item.menu?.connect('popped-up', menu => {
    self.toggleClassName('active');
    menu.connect('notify::visible', menu => {
      self.toggleClassName('active', menu.visible);
    });
    menu.disconnect(id);
  });

  if (id)
    self.connect('destroy', () => item.menu?.disconnect(id));
},
#+end_src

Setup for the systray item.

- =id= is an event listener to the =menu= property of =item=, if it exists. When the menu is popped up, it performs certain actions.
  - Toggles the =active= class on the button.
  - Adds another event listener to the =menu= for its visibility changes. This second listener toggles the =active= class based on whether the menu is visible or not.
- If the first listener was successfully connected, as indicated by =id=, a =destroy= event listener is added to the button. When a button is destroyed, it disconnects the first listener from the =menu=.

*** Click actions
#+name:systray-click-actions
#+begin_src js :tangle no :noweb yes
// @ts-expect-error popup_at_widget missing from types?
on_primary_click: btn => item.menu?.popup_at_widget(
  btn, Gdk.Gravity.SOUTH, Gdk.Gravity.NORTH, null),

// @ts-expect-error popup_at_widget missing from types?
on_secondary_click: btn => item.menu?.popup_at_widget(
  btn, Gdk.Gravity.SOUTH, Gdk.Gravity.NORTH, null),
#+end_src

** Export
Export an array of =SysTrayItem=.
#+begin_src js
export default () => Widget.Box({
    binds: [['children', SystemTray, 'items', i => i.map(SysTrayItem)]],
});
#+end_src

* System indicators
:PROPERTIES:
:header-args:js: :tangle SystemIndicators.js
:END:

Various system indicators for features such as Bluetooth, network, 'do not disturb' state, and audio.

** Imports
*** AGS service modules
#+begin_src js
import App from 'resource:///com/github/Aylur/ags/app.js';
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import Notifications from 'resource:///com/github/Aylur/ags/service/notifications.js';
import Bluetooth from 'resource:///com/github/Aylur/ags/service/bluetooth.js';
import Audio from 'resource:///com/github/Aylur/ags/service/audio.js';
import Network from 'resource:///com/github/Aylur/ags/service/network.js';
#+end_src

*** Panel buttons
#+begin_src js
import PanelButton from './PanelButton.js';
#+end_src

*** Hover revealer
#+begin_src js
import HoverRevealer from '../../../utils/hover-revealer/main.js';
#+end_src

*** On-screen indicator
#+begin_src js
import Indicator from '../../../utils/on-screen-indicator/main.js';
#+end_src

** Microphone indicator
#+begin_src js
const MicrophoneIndicator = () => Widget.Icon({
    connections: [[Audio, icon => {
        if (!Audio.microphone)
            return;

        const { muted, low, medium, high } = icons.audio.mic;
        if (Audio.microphone.is_muted)
            return icon.icon = muted;

        /** @type {Array<[number, string]>} */
        const cons = [[67, high], [34, medium], [1, low], [0, muted]];
        icon.icon = cons.find(([n]) => n <= Audio.microphone.volume * 100)?.[1] || '';

        icon.visible = Audio.recorders.length > 0 || Audio.microphone.is_muted;
    }]],
});
#+end_src


** Do not disturb indicator
#+begin_src js
const DNDIndicator = () => Widget.Icon({
    icon: icons.notifications.silent,
    binds: [['visible', Notifications, 'dnd']],
});
#+end_src

** Bluetooth devices indicator
Shows up if bluetooth is connected, indicating the type of device connected and, on hover, the name of the device.

#+begin_src js
const BluetoothDevicesIndicator = () => Widget.Box({
    class_name: 'bluetooth-devices-box',
    connections: [[Bluetooth, box => {
        box.children = Bluetooth.connectedDevices
            .map(({ iconName, name }) => HoverRevealer({
                indicator: Widget.Icon(iconName + '-symbolic'),
                child: Widget.Label(name + ' '),
            }));

        box.visible = Bluetooth.connectedDevices.length > 0;
    }, 'notify::connected-devices']],
});
#+end_src

** Bluetooth indicator
Indicates whether or not Bluetooth is active.

#+begin_src js
const BluetoothIndicator = () => Widget.Icon({
    class_name: 'bluetooth',
    icon: icons.bluetooth.enabled,
    binds: [['visible', Bluetooth, 'enabled']],
});
#+end_src

** Network indicator
#+begin_src js
const NetworkIndicator = () => Widget.Icon({
    connections: [[Network, self => {
        const icon = Network[Network.primary || 'wifi']?.iconName;
        self.icon = icon || '';
        self.visible = icon;
    }]],
});
#+end_src

** Audio indicator
#+begin_src js
const AudioIndicator = () => Widget.Icon({
    connections: [[Audio, icon => {
        if (!Audio.speaker)
            return;

        const { muted, low, medium, high, overamplified } = icons.audio.volume;
        if (Audio.speaker.is_muted)
            return icon.icon = muted;


        /** @type {Array<[number, string]>} */
        const cons = [[101, overamplified], [67, high], [34, medium], [1, low], [0, muted]];
        icon.icon = cons.find(([n]) => n <= Audio.speaker.volume * 100)?.[1] || '';
    }, 'speaker-changed']],
});
#+end_src

** Export
#+begin_src js
export default () => PanelButton({
    class_name: 'quicksettings panel-button',
    onClicked: () => App.toggleWindow('quicksettings'),
    onScrollUp: () => {
        Audio.speaker.volume += 0.02;
        Indicator.speaker();
    },
    onScrollDown: () => {
        Audio.speaker.volume -= 0.02;
        Indicator.speaker();
    },
    connections: [[App, (btn, win, visible) => {
        btn.toggleClassName('active', win === 'quicksettings' && visible);
    }]],
    child: Widget.Box({
        children: [
            BluetoothDevicesIndicator(),
            BluetoothIndicator(),
            NetworkIndicator(),
            AudioIndicator(),
            MicrophoneIndicator(),
            DNDIndicator(),
        ],
    }),
});
#+end_src

* Power menu button
:PROPERTIES:
:header-args:js: :tangle PowerMenu.js
:END:

Just a simple button to trigger the power menu.

** Imports
#+begin_src js
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import App from 'resource:///com/github/Aylur/ags/app.js';
import icons from '../../../config/icons.js';
import PanelButton from './PanelButton.js';
#+end_src

** Button
#+begin_src js
export default () => PanelButton({
    class_name: 'powermenu',
    content: Widget.Icon(icons.powermenu.shutdown),
    on_clicked: () => App.openWindow('powermenu'),
});
#+end_src

* Overview button
:PROPERTIES:
:header-args:js: :tangle OverviewButton.js
:END:

This is the button with the distro icon that shows the workspaces and active windows when pressed.

** Imports
#+begin_src js
import App from 'resource:///com/github/Aylur/ags/app.js';
import PanelButton from './PanelButton.js';
import FontIcon from '../../../utils/font-icon/main.js';
import { distroIcon } from '../../../config/variables.js';
import options from '../../../config/options.js';
#+end_src

** Button
#+begin_src js
export default () => PanelButton({
    class_name: 'overview',
    window: 'overview',
    on_clicked: () => App.toggleWindow('overview'),
    content: FontIcon({
        binds: [['icon', options.bar.icon, 'value', v => {
            return v === 'distro-icon' ? distroIcon : v;
        }]],
    }),
});
#+end_src

* Date and time
:PROPERTIES:
:header-args:js: :tangle DateButton.js
:END:

** Imports
#+begin_src js
import App from 'resource:///com/github/Aylur/ags/app.js';
import Clock from '../../../utils/clock/main.js';
import PanelButton from './PanelButton.js';
#+end_src

** Button
#+begin_src js
export default ({ format = '%a, %b %d %H:%M' } = {}) => PanelButton({
    class_name: 'dashboard panel-button',
    on_clicked: () => App.toggleWindow('dashboard'),
    window: 'dashboard',
    content: Clock({ format }),
});
#+end_src

* Sub-menu
:PROPERTIES:
:header-args:js: :tangle SubMenu.js
:END:

This is the revealer for elements such as the system tray.

** Imports
#+begin_src js
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import * as Utils from 'resource:///com/github/Aylur/ags/utils.js';
import Variable from 'resource:///com/github/Aylur/ags/variable.js';
import icons from '../../../config/icons.js';
import options from '../../../config/options.js';
#+end_src

** Arrow button
#+begin_src js :noweb yes
/**
 ,* @param {import('types/widgets/revealer').default} revealer
 ,* @param {'left' | 'right' | 'up' | 'down'} direction
 ,* @param {import('types/variable').Variable} items
 ,*/
const Arrow = (revealer, direction, items) => {
  let deg = 0;

  const icon = Widget.Icon({
    icon: icons.ui.arrow[direction],
  });

  <<submenu-animate>>

  return Widget.Button({
    class_name: 'panel-button sub-menu',
    connections: [[items, btn => {
      btn.tooltip_text = `${items.value} Items`;
    }]],
    on_clicked: () => {
      animate();
      revealer.reveal_child = !revealer.reveal_child;
    },
    child: icon,
  });
};

#+end_src

*** Animate
#+name:submenu-animate
#+begin_src js :noweb yes :tangle no
const animate = () => {
  const t = options.transition.value / 20;
  const step = revealer.reveal_child ? 10 : -10;
  for (let i = 0; i < 18; ++i) {
    Utils.timeout(t * i, () => {
      deg += step;
      icon.setCss(`-gtk-icon-transform: rotate(${deg}deg);`);
    });
  }
};
#+end_src

** Export
#+begin_src js
/**
 * @param {Object} o
 * @param {import('types/widgets/box').default['children']} o.children
 * @param {'left' | 'right' | 'up' | 'down'=} o.direction
 * @param {import('types/variable').Variable} o.items
 */
export default ({ children, direction = 'left', items = Variable(0) }) => {
    const posStart = direction === 'up' || direction === 'left';
    const posEnd = direction === 'down' || direction === 'right';
    const revealer = Widget.Revealer({
        transition: `slide_${direction}`,
        child: Widget.Box({
            children,
        }),
    });

    return Widget.Box({
        vertical: direction === 'up' || direction === 'down',
        children: [
            posStart && revealer,
            Arrow(revealer, direction, items),
            posEnd && revealer,
        ],
    });
};
#+end_src

* Media indicator
:PROPERTIES:
:header-args:js: :tangle MediaIndicator.js
:END:

** Imports
#+begin_src js
import Widget from 'resource:///com/github/Aylur/ags/widget.js';
import Mpris from 'resource:///com/github/Aylur/ags/service/mpris.js';
import * as Utils from 'resource:///com/github/Aylur/ags/utils.js';
import HoverRevealer from '../../../utils/hover-revealer/main.js';
import options from '../../../config/options.js';
#+end_src

** Get player
#+begin_src js
export const getPlayer = (name = options.mpris.preferred.value) =>
    Mpris.getPlayer(name) || Mpris.players[0] || null;
#+end_src

** Indicator
#+begin_src js

/**
 * @param {Object} o
 * @param {import('types/service/mpris').MprisPlayer} o.player
 * @param {import('../../misc/HoverRevealer').HoverRevealProps['direction']=} o.direction
 */
const Indicator = ({ player, direction = 'right' }) => HoverRevealer({
    class_name: `media panel-button ${player.name}`,
    direction,
    on_primary_click: () => player.playPause(),
    on_scroll_up: () => player.next(),
    on_scroll_down: () => player.previous(),
    on_secondary_click: () => player.playPause(),
    indicator: mpris.PlayerIcon(player),
    child: Widget.Label({
        vexpand: true,
        truncate: 'end',
        max_width_chars: 40,
        connections: [[player, label => {
            label.label = `${player.track_artists.join(', ')} - ${player.track_title}`;
        }]],
    }),
    connections: [[player, revealer => {
        if (revealer._current === player.track_title)
            return;

        revealer._current = player.track_title;
        revealer.reveal_child = true;
        Utils.timeout(3000, () => {
            revealer.reveal_child = false;
        });
    }]],
});
#+end_src

** Export
#+begin_src js
/**
 * @param {Object} o
 * @param {import('../../misc/HoverRevealer').HoverRevealProps['direction']=} o.direction
 */
export default ({ direction = 'right' } = {}) => {
    let current = null;

    const update = box => {
        const player = getPlayer();
        box.visible = !!player;

        if (!player) {
            current = null;
            return;
        }

        if (current === player)
            return;

        current = player;
        box.children = [Indicator({ player, direction })];
    };

    return Widget.Box({
        connections: [
            [options.mpris.preferred, update],
            [Mpris, update, 'notify::players'],
        ],
    });
};
#+end_src
